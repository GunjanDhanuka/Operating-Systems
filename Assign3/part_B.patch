diff -ruN xv6-public/.cvsignore b/.cvsignore
--- xv6-public/.cvsignore	2022-10-08 10:37:18.342659400 +0530
+++ b/.cvsignore	1970-01-01 05:30:00.000000000 +0530
@@ -1,16 +0,0 @@
-*.asm
-*.d
-*.sym
-_*
-kernel
-user1
-userfs
-usertests
-xv6.img
-vectors.S
-bochsout.txt
-bootblock
-bootother
-bootother.out
-parport.out
-fmt
diff -ruN xv6-public/.dir-locals.el b/.dir-locals.el
--- xv6-public/.dir-locals.el	2022-10-08 10:37:18.342659400 +0530
+++ b/.dir-locals.el	1970-01-01 05:30:00.000000000 +0530
@@ -1,4 +0,0 @@
-((c-mode
-  (indent-tabs-mode . nil)
-  (c-file-style . "bsd")
-  (c-basic-offset . 2)))
diff -ruN xv6-public/.gdbinit.tmpl b/.gdbinit.tmpl
--- xv6-public/.gdbinit.tmpl	2022-10-08 10:37:18.342659400 +0530
+++ b/.gdbinit.tmpl	1970-01-01 05:30:00.000000000 +0530
@@ -1,27 +0,0 @@
-set $lastcs = -1
-
-define hook-stop
-  # There doesn't seem to be a good way to detect if we're in 16- or
-  # 32-bit mode, but in 32-bit mode we always run with CS == 8 in the
-  # kernel and CS == 35 in user space
-  if $cs == 8 || $cs == 35
-    if $lastcs != 8 && $lastcs != 35
-      set architecture i386
-    end
-    x/i $pc
-  else
-    if $lastcs == -1 || $lastcs == 8 || $lastcs == 35
-      set architecture i8086
-    end
-    # Translate the segment:offset into a physical address
-    printf "[%4x:%4x] ", $cs, $eip
-    x/i $cs*16+$eip
-  end
-  set $lastcs = $cs
-end
-
-echo + target remote localhost:1234\n
-target remote localhost:1234
-
-echo + symbol-file kernel\n
-symbol-file kernel
diff -ruN xv6-public/.git/HEAD b/.git/HEAD
--- xv6-public/.git/HEAD	2022-10-08 10:37:18.342659400 +0530
+++ b/.git/HEAD	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-ref: refs/heads/master
diff -ruN xv6-public/.git/config b/.git/config
--- xv6-public/.git/config	2022-10-08 10:37:18.342659400 +0530
+++ b/.git/config	1970-01-01 05:30:00.000000000 +0530
@@ -1,11 +0,0 @@
-[core]
-	repositoryformatversion = 0
-	filemode = true
-	bare = false
-	logallrefupdates = true
-[remote "origin"]
-	url = https://github.com/mit-pdos/xv6-public
-	fetch = +refs/heads/*:refs/remotes/origin/*
-[branch "master"]
-	remote = origin
-	merge = refs/heads/master
diff -ruN xv6-public/.git/description b/.git/description
--- xv6-public/.git/description	2022-10-08 10:36:58.862659400 +0530
+++ b/.git/description	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-Unnamed repository; edit this file 'description' to name the repository.
diff -ruN xv6-public/.git/hooks/applypatch-msg.sample b/.git/hooks/applypatch-msg.sample
--- xv6-public/.git/hooks/applypatch-msg.sample	2022-10-08 10:36:58.862659400 +0530
+++ b/.git/hooks/applypatch-msg.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,15 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to check the commit log message taken by
-# applypatch from an e-mail message.
-#
-# The hook should exit with non-zero status after issuing an
-# appropriate message if it wants to stop the commit.  The hook is
-# allowed to edit the commit message file.
-#
-# To enable this hook, rename this file to "applypatch-msg".
-
-. git-sh-setup
-commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
-test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
-:
diff -ruN xv6-public/.git/hooks/commit-msg.sample b/.git/hooks/commit-msg.sample
--- xv6-public/.git/hooks/commit-msg.sample	2022-10-08 10:36:58.862659400 +0530
+++ b/.git/hooks/commit-msg.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,24 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to check the commit log message.
-# Called by "git commit" with one argument, the name of the file
-# that has the commit message.  The hook should exit with non-zero
-# status after issuing an appropriate message if it wants to stop the
-# commit.  The hook is allowed to edit the commit message file.
-#
-# To enable this hook, rename this file to "commit-msg".
-
-# Uncomment the below to add a Signed-off-by line to the message.
-# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
-# hook is more suited to it.
-#
-# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
-
-# This example catches duplicate Signed-off-by lines.
-
-test "" = "$(grep '^Signed-off-by: ' "$1" |
-	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
-	echo >&2 Duplicate Signed-off-by lines.
-	exit 1
-}
diff -ruN xv6-public/.git/hooks/fsmonitor-watchman.sample b/.git/hooks/fsmonitor-watchman.sample
--- xv6-public/.git/hooks/fsmonitor-watchman.sample	2022-10-08 10:36:58.862659400 +0530
+++ b/.git/hooks/fsmonitor-watchman.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,109 +0,0 @@
-#!/usr/bin/perl
-
-use strict;
-use warnings;
-use IPC::Open2;
-
-# An example hook script to integrate Watchman
-# (https://facebook.github.io/watchman/) with git to speed up detecting
-# new and modified files.
-#
-# The hook is passed a version (currently 1) and a time in nanoseconds
-# formatted as a string and outputs to stdout all files that have been
-# modified since the given time. Paths must be relative to the root of
-# the working tree and separated by a single NUL.
-#
-# To enable this hook, rename this file to "query-watchman" and set
-# 'git config core.fsmonitor .git/hooks/query-watchman'
-#
-my ($version, $time) = @ARGV;
-
-# Check the hook interface version
-
-if ($version == 1) {
-	# convert nanoseconds to seconds
-	# subtract one second to make sure watchman will return all changes
-	$time = int ($time / 1000000000) - 1;
-} else {
-	die "Unsupported query-fsmonitor hook version '$version'.\n" .
-	    "Falling back to scanning...\n";
-}
-
-my $git_work_tree;
-if ($^O =~ 'msys' || $^O =~ 'cygwin') {
-	$git_work_tree = Win32::GetCwd();
-	$git_work_tree =~ tr/\\/\//;
-} else {
-	require Cwd;
-	$git_work_tree = Cwd::cwd();
-}
-
-my $retry = 1;
-
-launch_watchman();
-
-sub launch_watchman {
-
-	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
-	    or die "open2() failed: $!\n" .
-	    "Falling back to scanning...\n";
-
-	# In the query expression below we're asking for names of files that
-	# changed since $time but were not transient (ie created after
-	# $time but no longer exist).
-	#
-	# To accomplish this, we're using the "since" generator to use the
-	# recency index to select candidate nodes and "fields" to limit the
-	# output to file names only.
-
-	my $query = <<"	END";
-		["query", "$git_work_tree", {
-			"since": $time,
-			"fields": ["name"]
-		}]
-	END
-
-	print CHLD_IN $query;
-	close CHLD_IN;
-	my $response = do {local $/; <CHLD_OUT>};
-
-	die "Watchman: command returned no output.\n" .
-	    "Falling back to scanning...\n" if $response eq "";
-	die "Watchman: command returned invalid output: $response\n" .
-	    "Falling back to scanning...\n" unless $response =~ /^\{/;
-
-	my $json_pkg;
-	eval {
-		require JSON::XS;
-		$json_pkg = "JSON::XS";
-		1;
-	} or do {
-		require JSON::PP;
-		$json_pkg = "JSON::PP";
-	};
-
-	my $o = $json_pkg->new->utf8->decode($response);
-
-	if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
-		print STDERR "Adding '$git_work_tree' to watchman's watch list.\n";
-		$retry--;
-		qx/watchman watch "$git_work_tree"/;
-		die "Failed to make watchman watch '$git_work_tree'.\n" .
-		    "Falling back to scanning...\n" if $? != 0;
-
-		# Watchman will always return all files on the first query so
-		# return the fast "everything is dirty" flag to git and do the
-		# Watchman query just to get it over with now so we won't pay
-		# the cost in git to look up each individual file.
-		print "/\0";
-		eval { launch_watchman() };
-		exit 0;
-	}
-
-	die "Watchman: $o->{error}.\n" .
-	    "Falling back to scanning...\n" if $o->{error};
-
-	binmode STDOUT, ":utf8";
-	local $, = "\0";
-	print @{$o->{files}};
-}
diff -ruN xv6-public/.git/hooks/post-update.sample b/.git/hooks/post-update.sample
--- xv6-public/.git/hooks/post-update.sample	2022-10-08 10:36:58.862659400 +0530
+++ b/.git/hooks/post-update.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,8 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to prepare a packed repository for use over
-# dumb transports.
-#
-# To enable this hook, rename this file to "post-update".
-
-exec git update-server-info
diff -ruN xv6-public/.git/hooks/pre-applypatch.sample b/.git/hooks/pre-applypatch.sample
--- xv6-public/.git/hooks/pre-applypatch.sample	2022-10-08 10:36:58.862659400 +0530
+++ b/.git/hooks/pre-applypatch.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed
-# by applypatch from an e-mail message.
-#
-# The hook should exit with non-zero status after issuing an
-# appropriate message if it wants to stop the commit.
-#
-# To enable this hook, rename this file to "pre-applypatch".
-
-. git-sh-setup
-precommit="$(git rev-parse --git-path hooks/pre-commit)"
-test -x "$precommit" && exec "$precommit" ${1+"$@"}
-:
diff -ruN xv6-public/.git/hooks/pre-commit.sample b/.git/hooks/pre-commit.sample
--- xv6-public/.git/hooks/pre-commit.sample	2022-10-08 10:36:58.862659400 +0530
+++ b/.git/hooks/pre-commit.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,49 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed.
-# Called by "git commit" with no arguments.  The hook should
-# exit with non-zero status after issuing an appropriate message if
-# it wants to stop the commit.
-#
-# To enable this hook, rename this file to "pre-commit".
-
-if git rev-parse --verify HEAD >/dev/null 2>&1
-then
-	against=HEAD
-else
-	# Initial commit: diff against an empty tree object
-	against=$(git hash-object -t tree /dev/null)
-fi
-
-# If you want to allow non-ASCII filenames set this variable to true.
-allownonascii=$(git config --bool hooks.allownonascii)
-
-# Redirect output to stderr.
-exec 1>&2
-
-# Cross platform projects tend to avoid non-ASCII filenames; prevent
-# them from being added to the repository. We exploit the fact that the
-# printable range starts at the space character and ends with tilde.
-if [ "$allownonascii" != "true" ] &&
-	# Note that the use of brackets around a tr range is ok here, (it's
-	# even required, for portability to Solaris 10's /usr/bin/tr), since
-	# the square bracket bytes happen to fall in the designated range.
-	test $(git diff --cached --name-only --diff-filter=A -z $against |
-	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
-then
-	cat <<\EOF
-Error: Attempt to add a non-ASCII file name.
-
-This can cause problems if you want to work with people on other platforms.
-
-To be portable it is advisable to rename the file.
-
-If you know what you are doing you can disable this check using:
-
-  git config hooks.allownonascii true
-EOF
-	exit 1
-fi
-
-# If there are whitespace errors, print the offending file names and fail.
-exec git diff-index --check --cached $against --
diff -ruN xv6-public/.git/hooks/pre-merge-commit.sample b/.git/hooks/pre-merge-commit.sample
--- xv6-public/.git/hooks/pre-merge-commit.sample	2022-10-08 10:36:58.862659400 +0530
+++ b/.git/hooks/pre-merge-commit.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,13 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed.
-# Called by "git merge" with no arguments.  The hook should
-# exit with non-zero status after issuing an appropriate message to
-# stderr if it wants to stop the merge commit.
-#
-# To enable this hook, rename this file to "pre-merge-commit".
-
-. git-sh-setup
-test -x "$GIT_DIR/hooks/pre-commit" &&
-        exec "$GIT_DIR/hooks/pre-commit"
-:
diff -ruN xv6-public/.git/hooks/pre-push.sample b/.git/hooks/pre-push.sample
--- xv6-public/.git/hooks/pre-push.sample	2022-10-08 10:36:58.862659400 +0530
+++ b/.git/hooks/pre-push.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,53 +0,0 @@
-#!/bin/sh
-
-# An example hook script to verify what is about to be pushed.  Called by "git
-# push" after it has checked the remote status, but before anything has been
-# pushed.  If this script exits with a non-zero status nothing will be pushed.
-#
-# This hook is called with the following parameters:
-#
-# $1 -- Name of the remote to which the push is being done
-# $2 -- URL to which the push is being done
-#
-# If pushing without using a named remote those arguments will be equal.
-#
-# Information about the commits which are being pushed is supplied as lines to
-# the standard input in the form:
-#
-#   <local ref> <local sha1> <remote ref> <remote sha1>
-#
-# This sample shows how to prevent push of commits where the log message starts
-# with "WIP" (work in progress).
-
-remote="$1"
-url="$2"
-
-z40=0000000000000000000000000000000000000000
-
-while read local_ref local_sha remote_ref remote_sha
-do
-	if [ "$local_sha" = $z40 ]
-	then
-		# Handle delete
-		:
-	else
-		if [ "$remote_sha" = $z40 ]
-		then
-			# New branch, examine all commits
-			range="$local_sha"
-		else
-			# Update to existing branch, examine new commits
-			range="$remote_sha..$local_sha"
-		fi
-
-		# Check for WIP commit
-		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
-		if [ -n "$commit" ]
-		then
-			echo >&2 "Found WIP commit in $local_ref, not pushing"
-			exit 1
-		fi
-	fi
-done
-
-exit 0
diff -ruN xv6-public/.git/hooks/pre-rebase.sample b/.git/hooks/pre-rebase.sample
--- xv6-public/.git/hooks/pre-rebase.sample	2022-10-08 10:36:58.862659400 +0530
+++ b/.git/hooks/pre-rebase.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,169 +0,0 @@
-#!/bin/sh
-#
-# Copyright (c) 2006, 2008 Junio C Hamano
-#
-# The "pre-rebase" hook is run just before "git rebase" starts doing
-# its job, and can prevent the command from running by exiting with
-# non-zero status.
-#
-# The hook is called with the following parameters:
-#
-# $1 -- the upstream the series was forked from.
-# $2 -- the branch being rebased (or empty when rebasing the current branch).
-#
-# This sample shows how to prevent topic branches that are already
-# merged to 'next' branch from getting rebased, because allowing it
-# would result in rebasing already published history.
-
-publish=next
-basebranch="$1"
-if test "$#" = 2
-then
-	topic="refs/heads/$2"
-else
-	topic=`git symbolic-ref HEAD` ||
-	exit 0 ;# we do not interrupt rebasing detached HEAD
-fi
-
-case "$topic" in
-refs/heads/??/*)
-	;;
-*)
-	exit 0 ;# we do not interrupt others.
-	;;
-esac
-
-# Now we are dealing with a topic branch being rebased
-# on top of master.  Is it OK to rebase it?
-
-# Does the topic really exist?
-git show-ref -q "$topic" || {
-	echo >&2 "No such branch $topic"
-	exit 1
-}
-
-# Is topic fully merged to master?
-not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
-if test -z "$not_in_master"
-then
-	echo >&2 "$topic is fully merged to master; better remove it."
-	exit 1 ;# we could allow it, but there is no point.
-fi
-
-# Is topic ever merged to next?  If so you should not be rebasing it.
-only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
-only_next_2=`git rev-list ^master           ${publish} | sort`
-if test "$only_next_1" = "$only_next_2"
-then
-	not_in_topic=`git rev-list "^$topic" master`
-	if test -z "$not_in_topic"
-	then
-		echo >&2 "$topic is already up to date with master"
-		exit 1 ;# we could allow it, but there is no point.
-	else
-		exit 0
-	fi
-else
-	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
-	/usr/bin/perl -e '
-		my $topic = $ARGV[0];
-		my $msg = "* $topic has commits already merged to public branch:\n";
-		my (%not_in_next) = map {
-			/^([0-9a-f]+) /;
-			($1 => 1);
-		} split(/\n/, $ARGV[1]);
-		for my $elem (map {
-				/^([0-9a-f]+) (.*)$/;
-				[$1 => $2];
-			} split(/\n/, $ARGV[2])) {
-			if (!exists $not_in_next{$elem->[0]}) {
-				if ($msg) {
-					print STDERR $msg;
-					undef $msg;
-				}
-				print STDERR " $elem->[1]\n";
-			}
-		}
-	' "$topic" "$not_in_next" "$not_in_master"
-	exit 1
-fi
-
-<<\DOC_END
-
-This sample hook safeguards topic branches that have been
-published from being rewound.
-
-The workflow assumed here is:
-
- * Once a topic branch forks from "master", "master" is never
-   merged into it again (either directly or indirectly).
-
- * Once a topic branch is fully cooked and merged into "master",
-   it is deleted.  If you need to build on top of it to correct
-   earlier mistakes, a new topic branch is created by forking at
-   the tip of the "master".  This is not strictly necessary, but
-   it makes it easier to keep your history simple.
-
- * Whenever you need to test or publish your changes to topic
-   branches, merge them into "next" branch.
-
-The script, being an example, hardcodes the publish branch name
-to be "next", but it is trivial to make it configurable via
-$GIT_DIR/config mechanism.
-
-With this workflow, you would want to know:
-
-(1) ... if a topic branch has ever been merged to "next".  Young
-    topic branches can have stupid mistakes you would rather
-    clean up before publishing, and things that have not been
-    merged into other branches can be easily rebased without
-    affecting other people.  But once it is published, you would
-    not want to rewind it.
-
-(2) ... if a topic branch has been fully merged to "master".
-    Then you can delete it.  More importantly, you should not
-    build on top of it -- other people may already want to
-    change things related to the topic as patches against your
-    "master", so if you need further changes, it is better to
-    fork the topic (perhaps with the same name) afresh from the
-    tip of "master".
-
-Let's look at this example:
-
-		   o---o---o---o---o---o---o---o---o---o "next"
-		  /       /           /           /
-		 /   a---a---b A     /           /
-		/   /               /           /
-	       /   /   c---c---c---c B         /
-	      /   /   /             \         /
-	     /   /   /   b---b C     \       /
-	    /   /   /   /             \     /
-    ---o---o---o---o---o---o---o---o---o---o---o "master"
-
-
-A, B and C are topic branches.
-
- * A has one fix since it was merged up to "next".
-
- * B has finished.  It has been fully merged up to "master" and "next",
-   and is ready to be deleted.
-
- * C has not merged to "next" at all.
-
-We would want to allow C to be rebased, refuse A, and encourage
-B to be deleted.
-
-To compute (1):
-
-	git rev-list ^master ^topic next
-	git rev-list ^master        next
-
-	if these match, topic has not merged in next at all.
-
-To compute (2):
-
-	git rev-list master..topic
-
-	if this is empty, it is fully merged to "master".
-
-DOC_END
diff -ruN xv6-public/.git/hooks/pre-receive.sample b/.git/hooks/pre-receive.sample
--- xv6-public/.git/hooks/pre-receive.sample	2022-10-08 10:36:58.862659400 +0530
+++ b/.git/hooks/pre-receive.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,24 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to make use of push options.
-# The example simply echoes all push options that start with 'echoback='
-# and rejects all pushes when the "reject" push option is used.
-#
-# To enable this hook, rename this file to "pre-receive".
-
-if test -n "$GIT_PUSH_OPTION_COUNT"
-then
-	i=0
-	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
-	do
-		eval "value=\$GIT_PUSH_OPTION_$i"
-		case "$value" in
-		echoback=*)
-			echo "echo from the pre-receive-hook: ${value#*=}" >&2
-			;;
-		reject)
-			exit 1
-		esac
-		i=$((i + 1))
-	done
-fi
diff -ruN xv6-public/.git/hooks/prepare-commit-msg.sample b/.git/hooks/prepare-commit-msg.sample
--- xv6-public/.git/hooks/prepare-commit-msg.sample	2022-10-08 10:36:58.862659400 +0530
+++ b/.git/hooks/prepare-commit-msg.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,42 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to prepare the commit log message.
-# Called by "git commit" with the name of the file that has the
-# commit message, followed by the description of the commit
-# message's source.  The hook's purpose is to edit the commit
-# message file.  If the hook fails with a non-zero status,
-# the commit is aborted.
-#
-# To enable this hook, rename this file to "prepare-commit-msg".
-
-# This hook includes three examples. The first one removes the
-# "# Please enter the commit message..." help message.
-#
-# The second includes the output of "git diff --name-status -r"
-# into the message, just before the "git status" output.  It is
-# commented because it doesn't cope with --amend or with squashed
-# commits.
-#
-# The third example adds a Signed-off-by line to the message, that can
-# still be edited.  This is rarely a good idea.
-
-COMMIT_MSG_FILE=$1
-COMMIT_SOURCE=$2
-SHA1=$3
-
-/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
-
-# case "$COMMIT_SOURCE,$SHA1" in
-#  ,|template,)
-#    /usr/bin/perl -i.bak -pe '
-#       print "\n" . `git diff --cached --name-status -r`
-# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
-#  *) ;;
-# esac
-
-# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
-# if test -z "$COMMIT_SOURCE"
-# then
-#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
-# fi
diff -ruN xv6-public/.git/hooks/update.sample b/.git/hooks/update.sample
--- xv6-public/.git/hooks/update.sample	2022-10-08 10:36:58.862659400 +0530
+++ b/.git/hooks/update.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,128 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to block unannotated tags from entering.
-# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
-#
-# To enable this hook, rename this file to "update".
-#
-# Config
-# ------
-# hooks.allowunannotated
-#   This boolean sets whether unannotated tags will be allowed into the
-#   repository.  By default they won't be.
-# hooks.allowdeletetag
-#   This boolean sets whether deleting tags will be allowed in the
-#   repository.  By default they won't be.
-# hooks.allowmodifytag
-#   This boolean sets whether a tag may be modified after creation. By default
-#   it won't be.
-# hooks.allowdeletebranch
-#   This boolean sets whether deleting branches will be allowed in the
-#   repository.  By default they won't be.
-# hooks.denycreatebranch
-#   This boolean sets whether remotely creating branches will be denied
-#   in the repository.  By default this is allowed.
-#
-
-# --- Command line
-refname="$1"
-oldrev="$2"
-newrev="$3"
-
-# --- Safety check
-if [ -z "$GIT_DIR" ]; then
-	echo "Don't run this script from the command line." >&2
-	echo " (if you want, you could supply GIT_DIR then run" >&2
-	echo "  $0 <ref> <oldrev> <newrev>)" >&2
-	exit 1
-fi
-
-if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
-	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
-	exit 1
-fi
-
-# --- Config
-allowunannotated=$(git config --bool hooks.allowunannotated)
-allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
-denycreatebranch=$(git config --bool hooks.denycreatebranch)
-allowdeletetag=$(git config --bool hooks.allowdeletetag)
-allowmodifytag=$(git config --bool hooks.allowmodifytag)
-
-# check for no description
-projectdesc=$(sed -e '1q' "$GIT_DIR/description")
-case "$projectdesc" in
-"Unnamed repository"* | "")
-	echo "*** Project description file hasn't been set" >&2
-	exit 1
-	;;
-esac
-
-# --- Check types
-# if $newrev is 0000...0000, it's a commit to delete a ref.
-zero="0000000000000000000000000000000000000000"
-if [ "$newrev" = "$zero" ]; then
-	newrev_type=delete
-else
-	newrev_type=$(git cat-file -t $newrev)
-fi
-
-case "$refname","$newrev_type" in
-	refs/tags/*,commit)
-		# un-annotated tag
-		short_refname=${refname##refs/tags/}
-		if [ "$allowunannotated" != "true" ]; then
-			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
-			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
-			exit 1
-		fi
-		;;
-	refs/tags/*,delete)
-		# delete tag
-		if [ "$allowdeletetag" != "true" ]; then
-			echo "*** Deleting a tag is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/tags/*,tag)
-		# annotated tag
-		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
-		then
-			echo "*** Tag '$refname' already exists." >&2
-			echo "*** Modifying a tag is not allowed in this repository." >&2
-			exit 1
-		fi
-		;;
-	refs/heads/*,commit)
-		# branch
-		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
-			echo "*** Creating a branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/heads/*,delete)
-		# delete branch
-		if [ "$allowdeletebranch" != "true" ]; then
-			echo "*** Deleting a branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/remotes/*,commit)
-		# tracking branch
-		;;
-	refs/remotes/*,delete)
-		# delete tracking branch
-		if [ "$allowdeletebranch" != "true" ]; then
-			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	*)
-		# Anything else (is there anything else?)
-		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
-		exit 1
-		;;
-esac
-
-# --- Finished
-exit 0
Binary files xv6-public/.git/index and b/.git/index differ
diff -ruN xv6-public/.git/info/exclude b/.git/info/exclude
--- xv6-public/.git/info/exclude	2022-10-08 10:36:58.862659400 +0530
+++ b/.git/info/exclude	1970-01-01 05:30:00.000000000 +0530
@@ -1,6 +0,0 @@
-# git ls-files --others --exclude-from=.git/info/exclude
-# Lines that start with '#' are comments.
-# For a project mostly in C, the following would be a good set of
-# exclude patterns (uncomment them if you want to use them):
-# *.[oa]
-# *~
diff -ruN xv6-public/.git/logs/HEAD b/.git/logs/HEAD
--- xv6-public/.git/logs/HEAD	2022-10-08 10:37:18.342659400 +0530
+++ b/.git/logs/HEAD	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Anindya Vijayvargeeya <an.vijay.q@gmail.com> 1665205638 +0530	clone: from https://github.com/mit-pdos/xv6-public
diff -ruN xv6-public/.git/logs/refs/heads/master b/.git/logs/refs/heads/master
--- xv6-public/.git/logs/refs/heads/master	2022-10-08 10:37:18.342659400 +0530
+++ b/.git/logs/refs/heads/master	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Anindya Vijayvargeeya <an.vijay.q@gmail.com> 1665205638 +0530	clone: from https://github.com/mit-pdos/xv6-public
diff -ruN xv6-public/.git/logs/refs/remotes/origin/HEAD b/.git/logs/refs/remotes/origin/HEAD
--- xv6-public/.git/logs/refs/remotes/origin/HEAD	2022-10-08 10:37:18.342659400 +0530
+++ b/.git/logs/refs/remotes/origin/HEAD	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Anindya Vijayvargeeya <an.vijay.q@gmail.com> 1665205638 +0530	clone: from https://github.com/mit-pdos/xv6-public
Binary files xv6-public/.git/objects/pack/pack-c6e0cd30f0b86ac0699382211cda02e663cb29d2.idx and b/.git/objects/pack/pack-c6e0cd30f0b86ac0699382211cda02e663cb29d2.idx differ
Binary files xv6-public/.git/objects/pack/pack-c6e0cd30f0b86ac0699382211cda02e663cb29d2.pack and b/.git/objects/pack/pack-c6e0cd30f0b86ac0699382211cda02e663cb29d2.pack differ
diff -ruN xv6-public/.git/packed-refs b/.git/packed-refs
--- xv6-public/.git/packed-refs	2022-10-08 10:37:18.342659400 +0530
+++ b/.git/packed-refs	1970-01-01 05:30:00.000000000 +0530
@@ -1,28 +0,0 @@
-# pack-refs with: peeled fully-peeled sorted 
-eeb7b415dbcb12cc362d0783e41c3d1f44066b17 refs/remotes/origin/master
-af0e851a3a8a7d13bc2f2d596b58500594040892 refs/tags/osdi12-submit
-^8286b58087750e09bac3815219e0382a0bb2b159
-9e698c587b135db17b38a5838976805b9c01e338 refs/tags/symlinks
-05e0b1218dcebe1f40028531b51926df8ae52be0 refs/tags/xv6-2006
-^5cc0bd5ceaf805ab44f851e6a3f1952a29e9d7b7
-42f3c3f7be9717b66ba6e133a113c0f751c53133 refs/tags/xv6-2007
-adcd16c3f7588b4a28d37495f05e94278c9e3a1e refs/tags/xv6-2008
-124fe7e457c0dc9b671c7ffccb56004eb61da4f0 refs/tags/xv6-2010
-5922cdbbcc4fdbd76eec9e0dad9f650e4c86ee99 refs/tags/xv6-rev0
-^5cc0bd5ceaf805ab44f851e6a3f1952a29e9d7b7
-81f31a773dd49b001437eaed3975438585ff9911 refs/tags/xv6-rev1
-^42f3c3f7be9717b66ba6e133a113c0f751c53133
-b818915f793cd20c5d1e24f668534a9d690f3cc8 refs/tags/xv6-rev11
-30dab73b68b816877dc8f78504ceca0808c976eb refs/tags/xv6-rev3
-^074ac7ccd43c08d01a237ce6f14cac10715a51ef
-113005d48f09a4e3939940d72a77bf6973ea8755 refs/tags/xv6-rev4
-^124fe7e457c0dc9b671c7ffccb56004eb61da4f0
-d6aa754494b37e32862b1f78d53deedc53f66a15 refs/tags/xv6-rev5
-^ae603ff5e79bb7b5eea4147425752f33d29fe558
-3e9d6413d331b4c912d55bfac253af1629d4bac9 refs/tags/xv6-rev6
-^e64c661ae8b91bd7e858bb1895bef96e6ac2b4bb
-ccc25c0fac59067d88af52ad9f3b8cee97c3810a refs/tags/xv6-rev7
-^2ae8392a5c203a7b1bc5b8bff5eabc8b5eab8972
-7d6f95e327f1c18570d5dd187e3d92e1aadae2cf refs/tags/xv6-rev8
-^9ba21267e796eb462a657392906e3cbccaedcc99
-5bf3fbee00fb27cb8cb4eca72dcd9fc4c288ed71 refs/tags/xv6-rev9
diff -ruN xv6-public/.git/refs/heads/master b/.git/refs/heads/master
--- xv6-public/.git/refs/heads/master	2022-10-08 10:37:18.342659400 +0530
+++ b/.git/refs/heads/master	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-eeb7b415dbcb12cc362d0783e41c3d1f44066b17
diff -ruN xv6-public/.git/refs/remotes/origin/HEAD b/.git/refs/remotes/origin/HEAD
--- xv6-public/.git/refs/remotes/origin/HEAD	2022-10-08 10:37:18.342659400 +0530
+++ b/.git/refs/remotes/origin/HEAD	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-ref: refs/remotes/origin/master
diff -ruN xv6-public/.gitignore b/.gitignore
--- xv6-public/.gitignore	2022-10-08 10:37:18.342659400 +0530
+++ b/.gitignore	1970-01-01 05:30:00.000000000 +0530
@@ -1,16 +0,0 @@
-*~
-_*
-*.o
-*.d
-*.asm
-*.sym
-*.img
-vectors.S
-bootblock
-entryother
-initcode
-initcode.out
-kernel
-kernelmemfs
-mkfs
-.gdbinit
diff -ruN xv6-public/Makefile b/Makefile
--- xv6-public/Makefile	2022-10-08 10:37:18.342659400 +0530
+++ b/Makefile	2022-10-31 13:49:45.090000000 +0530
@@ -143,7 +143,7 @@
 vectors.S: vectors.pl
 	./vectors.pl > vectors.S
 
-ULIB = ulib.o usys.o printf.o umalloc.o
+ULIB = ulib.o usys.o printf.o umalloc.o random.o
 
 _%: %.o $(ULIB)
 	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
@@ -181,6 +181,7 @@
 	_usertests\
 	_wc\
 	_zombie\
+	_memtest\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -249,8 +250,8 @@
 
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
-	printf.c umalloc.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c memtest.c\
+	printf.c umalloc.c random.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
 
diff -ruN xv6-public/defs.h b/defs.h
--- xv6-public/defs.h	2022-10-08 10:37:18.352659400 +0530
+++ b/defs.h	2022-10-31 17:59:51.129870300 +0530
@@ -9,6 +9,7 @@
 struct sleeplock;
 struct stat;
 struct superblock;
+struct rq;
 
 // bio.c
 void            binit(void);
@@ -120,6 +121,15 @@
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+void 			      create_kernel_process(const char *, void (*)());
+void 		      	swap_out_process_function();
+void 		      	swap_in_process_function();
+int             rpush( struct rq* , struct proc *p);
+struct proc*    rpop(struct rq *);
+extern int swap_out_process_exists;
+extern int swap_in_process_exists;
+extern struct rq rqueue_out;
+extern struct rq rqueue_in;
 
 // swtch.S
 void            swtch(struct context**, struct context*);
@@ -164,6 +174,7 @@
 extern uint     ticks;
 void            tvinit(void);
 extern struct spinlock tickslock;
+extern struct spinlock swap_in_lock;
 
 // uart.c
 void            uartinit(void);
@@ -185,6 +196,9 @@
 void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
+extern 			char * sleeping_channel;
+extern struct spinlock sleeping_channel_lock;
+extern 			int sleeping_channel_count;
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff -ruN xv6-public/exec.c b/exec.c
--- xv6-public/exec.c	2022-10-08 10:37:18.352659400 +0530
+++ b/exec.c	2022-10-31 13:49:45.090000000 +0530
@@ -6,6 +6,7 @@
 #include "defs.h"
 #include "x86.h"
 #include "elf.h"
+#include "fcntl.h"
 
 int
 exec(char *path, char **argv)
diff -ruN xv6-public/fs.c b/fs.c
--- xv6-public/fs.c	2022-10-08 10:37:18.352659400 +0530
+++ b/fs.c	2022-10-31 13:49:45.090000000 +0530
@@ -331,7 +331,9 @@
 void
 iput(struct inode *ip)
 {
+
   acquiresleep(&ip->lock);
+
   if(ip->valid && ip->nlink == 0){
     acquire(&icache.lock);
     int r = ip->ref;
diff -ruN xv6-public/kalloc.c b/kalloc.c
--- xv6-public/kalloc.c	2022-10-08 10:37:18.352659400 +0530
+++ b/kalloc.c	2022-10-31 13:49:45.090000000 +0530
@@ -8,19 +8,20 @@
 #include "memlayout.h"
 #include "mmu.h"
 #include "spinlock.h"
+#include "proc.h"
 
 void freerange(void *vstart, void *vend);
 extern char end[]; // first address after kernel loaded from ELF file
                    // defined by the kernel linker script in kernel.ld
 
-struct run {
+struct run {          
   struct run *next;
 };
 
-struct {
+struct {            
   struct spinlock lock;
   int use_lock;
-  struct run *freelist;
+  struct run *freelist; 
 } kmem;
 
 // Initialization happens in two phases.
@@ -59,13 +60,19 @@
 void
 kfree(char *v)
 {
+
   struct run *r;
+  // struct proc *p=myproc();
 
-  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
+  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP){
     panic("kfree");
+  }
 
   // Fill with junk to catch dangling refs.
-  memset(v, 1, PGSIZE);
+  // memset(v, 1, PGSIZE);
+  for(int i=0;i<PGSIZE;i++){
+    v[i]=1;
+  }
 
   if(kmem.use_lock)
     acquire(&kmem.lock);
@@ -74,6 +81,17 @@
   kmem.freelist = r;
   if(kmem.use_lock)
     release(&kmem.lock);
+
+  //Wake up processes sleeping on sleeping channel.
+  if(kmem.use_lock)
+    acquire(&sleeping_channel_lock);
+  if(sleeping_channel_count){
+    wakeup(sleeping_channel);
+    sleeping_channel_count=0;
+  }
+  if(kmem.use_lock)
+    release(&sleeping_channel_lock);
+
 }
 
 // Allocate one 4096-byte page of physical memory.
diff -ruN xv6-public/main.c b/main.c
--- xv6-public/main.c	2022-10-08 10:37:18.352659400 +0530
+++ b/main.c	2022-10-31 13:49:45.090000000 +0530
@@ -14,6 +14,7 @@
 // Bootstrap processor starts running C code here.
 // Allocate a real stack and switch to it, first
 // doing some setup required for memory allocator to work.
+
 int
 main(void)
 {
@@ -30,11 +31,13 @@
   tvinit();        // trap vectors
   binit();         // buffer cache
   fileinit();      // file table
-  ideinit();       // disk 
+  ideinit();       // disk
   startothers();   // start other processors
   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
   userinit();      // first user process
+  // create_kernel_process("swap_out_process", &swap_out_process_function);
   mpmain();        // finish this processor's setup
+
 }
 
 // Other CPUs jump here from entryother.S.
diff -ruN xv6-public/memlayout.h b/memlayout.h
--- xv6-public/memlayout.h	2022-10-08 10:37:18.352659400 +0530
+++ b/memlayout.h	2022-10-31 19:56:11.615803500 +0530
@@ -1,7 +1,7 @@
 // Memory layout
 
 #define EXTMEM  0x100000            // Start of extended memory
-#define PHYSTOP 0xE000000           // Top physical memory
+#define PHYSTOP 0x0400000           // Top physical memory
 #define DEVSPACE 0xFE000000         // Other devices are at high addresses
 
 // Key addresses for address space layout (see kmap in vm.c for layout)
diff -ruN xv6-public/memtest.c b/memtest.c
--- xv6-public/memtest.c	1970-01-01 05:30:00.000000000 +0530
+++ b/memtest.c	2022-10-31 17:57:41.319870300 +0530
@@ -0,0 +1,51 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int generate_vals(int x){
+	return (x*x*x) - x + 1; // x^3 - x + 1 
+}
+
+int main(int argc, char* argv[]){
+	int childno, iterno;
+
+	for(childno = 1; childno <= 20; childno++){
+		int pid = fork();
+
+		if(pid < 0){
+			printf(1, "Fork failed\n");
+			exit();
+		}
+
+		if( pid == 0 ){
+			printf(1, "Child %d\n", childno);
+			for(iterno = 1; iterno <= 10; iterno++){
+				int *arr = malloc(4096);
+				// filling values
+				for(int k=0;k<1024;k++){
+					arr[k] = generate_vals(k);
+				}
+
+				int validated=0;
+				// validating with the same function
+				for(int k=0;k<1024;k++){
+					if(arr[k] == generate_vals(k))
+						validated++;
+				}
+				if(validated == 1024){
+					printf(1, "Iteration : %d\t Validation successful\n", iterno);
+				} else {
+					printf(1, "Iteration : %d\t Validation failed, not matched %dB\n", 
+						iterno, (4096 - (validated*4))
+					);
+				}
+			}
+			printf(1, "\n");
+			exit();
+		}
+	}
+
+	while(wait()!=-1);
+	exit();
+
+}
diff -ruN xv6-public/mmu.h b/mmu.h
--- xv6-public/mmu.h	2022-10-08 10:37:18.352659400 +0530
+++ b/mmu.h	2022-10-31 14:14:10.570000000 +0530
@@ -94,6 +94,8 @@
 #define PTE_P           0x001   // Present
 #define PTE_W           0x002   // Writeable
 #define PTE_U           0x004   // User
+#define PTE_A           0x020   // Accessed
+#define PTE_D           0x040   // Dirty
 #define PTE_PS          0x080   // Page Size
 
 // Address in page table or page directory entry
diff -ruN xv6-public/param.h b/param.h
--- xv6-public/param.h	2022-10-08 10:37:18.352659400 +0530
+++ b/param.h	2022-10-31 13:49:45.090000000 +0530
@@ -1,6 +1,6 @@
 #define NPROC        64  // maximum number of processes
 #define KSTACKSIZE 4096  // size of per-process kernel stack
-#define NCPU          8  // maximum number of CPUs
+#define NCPU          1  // maximum number of CPUs
 #define NOFILE       16  // open files per process
 #define NFILE       100  // open files per system
 #define NINODE       50  // maximum number of active i-nodes
diff -ruN xv6-public/proc.c b/proc.c
--- xv6-public/proc.c	2022-10-08 10:37:18.352659400 +0530
+++ b/proc.c	2022-10-31 21:54:41.842309800 +0530
@@ -3,9 +3,350 @@
 #include "param.h"
 #include "memlayout.h"
 #include "mmu.h"
+#include "stat.h"
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
+#include "fcntl.h"
+#include "sleeplock.h"
+#include "fs.h"
+#include "file.h"
+
+int swap_out_process_exists=0;
+int swap_in_process_exists=0;
+
+int mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm);
+
+int 
+proc_read(int fd, int n, char *p)
+{
+  struct file *f;
+  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+  return -1;
+  return fileread(f, p, n);
+
+}
+
+int
+proc_write(int fd, char *p, int n)
+{
+  struct file *f;
+  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+    return -1;
+  return filewrite(f, p, n);
+}
+
+int
+proc_close(int fd)
+{
+  struct file *f;
+
+  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+    return -1;
+  
+  myproc()->ofile[fd] = 0;
+  fileclose(f);
+  return 0;
+}
+
+
+static struct inode*
+proc_create(char *path, short type, short major, short minor)
+{
+  struct inode *ip, *dp;
+  char name[DIRSIZ];
+
+  if((dp = nameiparent(path, name)) == 0)
+    return 0;
+  ilock(dp);
+
+  if((ip = dirlookup(dp, name, 0)) != 0){
+    iunlockput(dp);
+    ilock(ip);
+    if(type == T_FILE && ip->type == T_FILE)
+      return ip;
+    iunlockput(ip);
+    return 0;
+  }
+
+  if((ip = ialloc(dp->dev, type)) == 0)
+    panic("create: ialloc");
+
+  ilock(ip);
+  ip->major = major;
+  ip->minor = minor;
+  ip->nlink = 1;
+  iupdate(ip);
+
+  if(type == T_DIR){  // Create . and .. entries.
+    dp->nlink++;  // for ".."
+    iupdate(dp);
+    // No ip->nlink++ for ".": avoid cyclic ref count.
+    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+      panic("create dots");
+  }
+
+  if(dirlink(dp, name, ip->inum) < 0)
+    panic("create: dirlink");
+
+  iunlockput(dp);
+
+  return ip;
+}
+
+
+static int
+proc_fdalloc(struct file *f)
+{
+  int fd;
+  struct proc *curproc = myproc();
+
+  for(fd = 0; fd < NOFILE; fd++){
+    if(curproc->ofile[fd] == 0){
+      curproc->ofile[fd] = f;
+      return fd;
+    }
+  }
+  return -1;
+}
+
+int proc_open(char *path, int omode){
+
+  int fd;
+  struct file *f;
+  struct inode *ip;
+
+  begin_op();
+
+  if(omode & O_CREATE){
+    ip = proc_create(path, T_FILE, 0, 0);
+    if(ip == 0){
+      end_op();
+      return -1;
+    }
+  } else {
+    if((ip = namei(path)) == 0){
+      end_op();
+      return -1;
+    }
+    ilock(ip);
+    if(ip->type == T_DIR && omode != O_RDONLY){
+      iunlockput(ip);
+      end_op();
+      return -1;
+    }
+  }
+
+  if((f = filealloc()) == 0 || (fd = proc_fdalloc(f)) < 0){
+    if(f)
+      fileclose(f);
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+  iunlock(ip);
+  end_op();
+
+  f->type = FD_INODE;
+  f->ip = ip;
+  f->off = 0;
+  f->readable = !(omode & O_WRONLY);
+  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+  return fd;
+
+}
+
+void int_to_string(int x, char *c){
+  if(x==0)
+  {
+    c[0]='0';
+    c[1]='\0';
+    return;
+  }
+  int i=0;
+  while(x>0){
+    c[i]=x%10+'0';
+    i++;
+    x/=10;
+  }
+  c[i]='\0';
+
+  for(int j=0;j<i/2;j++){
+    char a=c[j];
+    c[j]=c[i-j-1];
+    c[i-j-1]=a;
+  }
+
+}
+
+struct rq{
+  struct spinlock lock;
+  struct proc* queue[NPROC];
+  int s;
+  int e;
+};
+
+// circular request queue for swapping out requests.
+struct rq rqueue_out;
+// circular request queue for swapping in requests.
+struct rq rqueue_in;
+
+struct proc* rpop( struct rq* q){
+
+  acquire(&q->lock);
+  if(q->s==q->e){
+  	release(&q->lock);
+  	return 0;
+  }
+  struct proc *p=q->queue[q->s];
+  (q->s)++;
+  (q->s)%=NPROC;
+  release(&q->lock);
+
+  return p;
+}
+
+int rpush( struct rq* q, struct proc *p){
+
+  acquire(&q->lock);
+  if((q->e+1)%NPROC==q->s){
+  	release(&q->lock);
+    return 0;
+  }
+  q->queue[q->e]=p;
+  q->e++;
+  (q->e)%=NPROC;
+  release(&q->lock);
+  
+  return 1;
+}
+
+ 
+void swap_out_process_function(){
+
+  int swapped_out;
+  acquire(&rqueue_out.lock);
+  while(rqueue_out.s!=rqueue_out.e){
+    struct proc *p = rpop(&rqueue_out);
+    swapped_out = 0;
+
+    pde_t* pd = p->pgdir;
+    for(int lvl = 0; lvl < 4 ; lvl ++) {
+      if(swapped_out) break;
+
+      for(int i=0;i<NPDENTRIES;i++){
+        if(swapped_out) break;
+
+        //skip page table if accessed. chances are high, not every page table was accessed.
+        if( ( pd[i] & ( PTE_A | PTE_D ) ) !=  ( lvl << 5) )
+          continue;
+        //else
+        pte_t *pgtab = (pte_t*)P2V(PTE_ADDR(pd[i]));
+        for(int j=0;j<NPTENTRIES;j++){
+
+          //Skip if found
+          if(( (pd[i] & ( PTE_A | PTE_D )) != (lvl <<5) ) || !(pgtab[j]&PTE_P))
+            continue;
+          pte_t *pte=(pte_t*)P2V(PTE_ADDR(pgtab[j]));
+
+          //for file name
+          int pid=p->pid;
+          int virt = ((1<<22)*i)+((1<<12)*j);
+
+          //file name
+          char c[50];
+          int_to_string(pid,c);
+          int x=strlen(c);
+          c[x]='_';
+          int_to_string(virt,c+x+1);
+          safestrcpy(c+strlen(c),".swp",5);
+
+          // file management
+          int fd=proc_open(c, O_CREATE | O_RDWR);
+          if(fd<0){
+            cprintf("error creating or opening file: %s\n", c);
+            panic("swap_out_process");
+          }
+
+          if(proc_write(fd,(char *)pte, PGSIZE) != PGSIZE){
+            cprintf("error writing to file: %s\n", c);
+            panic("swap_out_process");
+          }
+          proc_close(fd);
+
+          kfree((char*)pte);
+          // memset(&pgtab[j],0,sizeof(pgtab[j]));
+          pgtab[j]^=PTE_P;
+
+          //mark this page as being swapped out.
+          pgtab[j]=((pgtab[j])^(0x080));
+
+          swapped_out = 1; break;
+        }
+      }
+    }
+
+  }
+
+  release(&rqueue_out.lock);
+  
+  struct proc *p;
+  if((p=myproc())==0)
+    panic("swap out process");
+
+  swap_out_process_exists=0;
+  p->parent = 0;
+  p->name[0] = '*';
+  p->killed = 0;
+  p->state = UNUSED;
+  sched();
+}
+
+void swap_in_process_function(){
+
+	acquire(&rqueue_in.lock);
+	while(rqueue_in.s!=rqueue_in.e){
+		struct proc *p = rpop(&rqueue_in);
+
+		int pid=p->pid;
+		int virt=PTE_ADDR(p->addr);
+
+    char c[50];
+    int_to_string(pid,c);
+    int x=strlen(c);
+    c[x]='_';
+    int_to_string(virt,c+x+1);
+    safestrcpy(c+strlen(c),".swp",5);
+
+    int fd=proc_open(c,O_RDONLY);
+    if(fd<0){
+      release(&rqueue_in.lock);
+      cprintf("could not find page file in memory: %s\n", c);
+      panic("swap_in_process");
+    }
+    char *mem=kalloc();
+    proc_read(fd,PGSIZE,mem);
+
+    if(mappages(p->pgdir, (void *)virt, PGSIZE, V2P(mem), PTE_W|PTE_U)<0){
+      release(&rqueue_in.lock);
+      panic("mappages");
+    }
+    wakeup(p);
+	}
+
+  release(&rqueue_in.lock);
+  struct proc *p;
+	if((p=myproc())==0)
+	  panic("swap_in_process");
+
+	swap_in_process_exists=0;
+	p->parent = 0;
+	p->name[0] = '*';
+	p->killed = 0;
+	p->state = UNUSED;
+	sched();
+
+}
 
 struct {
   struct spinlock lock;
@@ -24,6 +365,9 @@
 pinit(void)
 {
   initlock(&ptable.lock, "ptable");
+  initlock(&rqueue_out.lock, "rqueue");
+  initlock(&sleeping_channel_lock, "sleeping_channel");
+  initlock(&rqueue_in.lock, "rqueue2");
 }
 
 // Must be called with interrupts disabled
@@ -115,11 +459,46 @@
   return p;
 }
 
+void create_kernel_process(const char *name, void (*entrypoint)()){
+    
+  struct proc *p = allocproc();
+
+  if(p == 0)
+    panic("create_kernel_process failed");
+
+  //Setting up kernel page table using setupkvm
+  if((p->pgdir = setupkvm()) == 0)
+    panic("setupkvm failed");
+
+  //This is a kernel process. Trap frame stores user space registers. We don't need to initialise tf.
+  //Also, since this doesn't need to have a userspace, we don't need to assign a size to this process.
+
+  //eip stores address of next instruction to be executed
+  p->context->eip = (uint)entrypoint;
+
+  safestrcpy(p->name, name, sizeof(p->name));
+
+  acquire(&ptable.lock);
+  p->state = RUNNABLE;
+  release(&ptable.lock);
+
+}
+
 //PAGEBREAK: 32
 // Set up first user process.
 void
 userinit(void)
 {
+  acquire(&rqueue_in.lock);
+  rqueue_in.s=0;
+  rqueue_in.e=0;
+  release(&rqueue_in.lock);
+
+  acquire(&rqueue_out.lock);
+  rqueue_out.s=0;
+  rqueue_out.e=0;
+  release(&rqueue_out.lock);
+
   struct proc *p;
   extern char _binary_initcode_start[], _binary_initcode_size[];
 
@@ -151,6 +530,7 @@
   p->state = RUNNABLE;
 
   release(&ptable.lock);
+
 }
 
 // Grow current process's memory by n bytes.
@@ -180,6 +560,7 @@
 int
 fork(void)
 {
+
   int i, pid;
   struct proc *np;
   struct proc *curproc = myproc();
@@ -227,6 +608,7 @@
 void
 exit(void)
 {
+
   struct proc *curproc = myproc();
   struct proc *p;
   int fd;
@@ -242,6 +624,7 @@
     }
   }
 
+
   begin_op();
   iput(curproc->cwd);
   end_op();
@@ -333,6 +716,14 @@
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      //If the swap out process has stopped running, free its stack and name.
+      if(p->state==UNUSED && p->name[0]=='*'){
+
+        kfree(p->kstack);
+        p->kstack=0;
+        p->name[0]=0;
+        p->pid=0;
+      }
       if(p->state != RUNNABLE)
         continue;
 
@@ -365,6 +756,7 @@
 void
 sched(void)
 {
+
   int intena;
   struct proc *p = myproc();
 
diff -ruN xv6-public/proc.h b/proc.h
--- xv6-public/proc.h	2022-10-08 10:37:18.352659400 +0530
+++ b/proc.h	2022-10-31 13:49:45.090000000 +0530
@@ -49,6 +49,8 @@
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int addr;                    // ADDED: Virtual address of pagefault
+
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff -ruN xv6-public/sleeplock.c b/sleeplock.c
--- xv6-public/sleeplock.c	2022-10-08 10:37:18.352659400 +0530
+++ b/sleeplock.c	2022-10-31 13:49:45.090000000 +0530
@@ -22,10 +22,13 @@
 void
 acquiresleep(struct sleeplock *lk)
 {
+
   acquire(&lk->lk);
+
   while (lk->locked) {
     sleep(lk, &lk->lk);
   }
+
   lk->locked = 1;
   lk->pid = myproc()->pid;
   release(&lk->lk);
diff -ruN xv6-public/spinlock.c b/spinlock.c
--- xv6-public/spinlock.c	2022-10-08 10:37:18.352659400 +0530
+++ b/spinlock.c	2022-10-31 13:49:45.090000000 +0530
@@ -25,6 +25,7 @@
 acquire(struct spinlock *lk)
 {
   pushcli(); // disable interrupts to avoid deadlock.
+
   if(holding(lk))
     panic("acquire");
 
diff -ruN xv6-public/trap.c b/trap.c
--- xv6-public/trap.c	2022-10-08 10:37:18.352659400 +0530
+++ b/trap.c	2022-10-31 17:59:56.259870300 +0530
@@ -14,6 +14,30 @@
 struct spinlock tickslock;
 uint ticks;
 
+struct spinlock swap_in_lock;
+
+void handlePageFault(){
+  int addr=rcr2();
+  struct proc *p=myproc();
+  acquire(&swap_in_lock);
+  sleep(p,&swap_in_lock);
+  pde_t *pde = &(p->pgdir)[PDX(addr)];
+  pte_t *pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+
+  if((pgtab[PTX(addr)])&0x080){
+    //This means that the page was swapped out.
+    //virtual address for page
+    p->addr = addr;
+    rpush(&rqueue_in,p);
+    if(!swap_in_process_exists){
+      swap_in_process_exists=1;
+      create_kernel_process("swap_in_process", &swap_in_process_function);
+    }
+  } else {
+    exit();
+  }
+}
+
 void
 tvinit(void)
 {
@@ -77,7 +101,9 @@
             cpuid(), tf->cs, tf->eip);
     lapiceoi();
     break;
-
+  case T_PGFLT:
+    handlePageFault();
+  break;
   //PAGEBREAK: 13
   default:
     if(myproc() == 0 || (tf->cs&3) == 0){
@@ -102,9 +128,9 @@
 
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
-  if(myproc() && myproc()->state == RUNNING &&
-     tf->trapno == T_IRQ0+IRQ_TIMER)
-    yield();
+  // if(myproc() && myproc()->state == RUNNING &&
+  //    tf->trapno == T_IRQ0+IRQ_TIMER)
+  //   yield();
 
   // Check if the process has been killed since we yielded
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
diff -ruN xv6-public/ulib.c b/ulib.c
--- xv6-public/ulib.c	2022-10-08 10:37:18.352659400 +0530
+++ b/ulib.c	2022-10-31 13:49:45.090000000 +0530
@@ -36,6 +36,7 @@
 void*
 memset(void *dst, int c, uint n)
 {
+
   stosb(dst, c, n);
   return dst;
 }
diff -ruN xv6-public/user.h b/user.h
--- xv6-public/user.h	2022-10-08 10:37:18.352659400 +0530
+++ b/user.h	2022-10-31 13:49:45.090000000 +0530
@@ -37,3 +37,4 @@
 void* malloc(uint);
 void free(void*);
 int atoi(const char*);
+int randomrange(int, int);
diff -ruN xv6-public/vm.c b/vm.c
--- xv6-public/vm.c	2022-10-08 10:37:18.352659400 +0530
+++ b/vm.c	2022-10-31 22:04:37.552309800 +0530
@@ -6,10 +6,15 @@
 #include "mmu.h"
 #include "proc.h"
 #include "elf.h"
+#include "spinlock.h"
 
 extern char data[];  // defined by kernel.ld
 pde_t *kpgdir;  // for use in scheduler()
 
+struct spinlock sleeping_channel_lock;
+int sleeping_channel_count=0;
+char * sleeping_channel;
+
 // Set up CPU's kernel segment descriptors.
 // Run once on entry on each CPU.
 void
@@ -57,7 +62,7 @@
 // Create PTEs for virtual addresses starting at va that refer to
 // physical addresses starting at pa. va and size might not
 // be page-aligned.
-static int
+int
 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
 {
   char *a, *last;
@@ -233,8 +238,22 @@
   for(; a < newsz; a += PGSIZE){
     mem = kalloc();
     if(mem == 0){
-      cprintf("allocuvm out of memory\n");
+      // cprintf("allocuvm out of memory\n");
       deallocuvm(pgdir, newsz, oldsz);
+
+      //SLEEP
+      myproc()->state=SLEEPING;
+      acquire(&sleeping_channel_lock);
+      myproc()->chan=sleeping_channel;
+      sleeping_channel_count++;
+      release(&sleeping_channel_lock);
+
+	     rpush(&rqueue_out,myproc());
+      if(!swap_out_process_exists){
+        swap_out_process_exists=1;
+        create_kernel_process("swap_out_process", &swap_out_process_function);
+      }
+      
       return 0;
     }
     memset(mem, 0, PGSIZE);
